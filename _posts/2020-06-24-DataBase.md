---
layout: post
title: 数据库复习
subtitle: Part I：题目整理
cover-img: /assets/img/path.jpg
tags: [database]
categories: ['DataBase']
---

这一篇是对于数据库方面一些题目的整理，如果后续有时间的话，会对数据库做一下系统的整理，加油！

# 数据库



- ### #数据库的索引


* 索引的原理

 {:.box-warning}
  
  what is index?

   索引是一种类似目录的文件，对数据库表中的一个或者多个列进行排序的结构，帮助数据库实现快速查询、更新等操作。
   
   
 
* 索引的类型


   从索引的实现上，我们可以将其分为聚集索引与非聚集索引，或称辅助索引或二级索引，这两大类；
   
   从索引的实际应用中，又可以细分为普通索引、唯一索引、主键索引、联合索引、外键索引、全文索引这几种。


    * 聚集索引
    
        聚集索引中的数据是按照索引顺序来存储的，聚集索引的叶子结点存储了真实的数据行，没有其他单独的数据页
    
    
    * 非聚集索引
    
        非聚集索引中，数据存储顺序与索引顺序无关，非聚集索引的叶子结点包含索引字段和指向数据页的逻辑指针
    
    
    * 唯一索引
    
        是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中不可以重复。
        
        
    * 主键索引
    
        是唯一索引的特定类型。表中创建主键时自动创建的索引 。一个表只能建立一个主索引。
        

* 什么样的信息能成为索引？

    -主键，唯一键，普通键等让数据具备一定区分性的字段


* 什么情况下适合建立索引

    -经常出现在关键字order by ,group by , distinct 后面的字段
    
    -union等集合操作的结果集字段
    
    -经常查询的字段

    -经常用作表连接的属性




* 索引的作用


   * 索引提高了检索效率，加快了检索速度
   
   * 唯一索引可以保证每行数据的唯一性
   
   * 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
   
   
   缺点：
   
   * 索引需要占物理和数据空间

   * 索引降低了插入、删除、修改等维护任务的速度


* 覆盖索引：当要查询的信息已经包含在索引中了就不需要再回表查询一次了，减少IO的次数

  因此使用联合索引来达到这个优化的目的
  
  
  * 最左匹配原则：mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引。（而且第一个索引必须是等值匹配）。
  
    -列的排列顺序决定了可命中索引的列数
      
      mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配
      
      ```
      比如a=3 and b=4 and c>5 and d=6
      如果建立（a,b,c,d）顺序的索引，d是用不到索引的
      如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。
      =和in可以乱序，比如a=1 and b =2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式
      当创建一个联合索引时,如(key1,key2,key3),相当于他建了(key1),(key1,key2),(key1,key2.key3)
      
      ```


    -索引失效
    
    
     -若条件中有or,即使其中有条件带索引也不会使用(尽量少使用or的原因)

     -对于多列索引,不是使用的第一部分,则不会使用索引

     -like查询是以%开头
     
     -如果列类型是字符串,要在条件中使用绰号引起来,否则不会使用索引

     -如果MySQL估计使用全表扫描比索引快,则不使用索引




- ### # B树和B+树

为了在索引上采用高级的搜索方法，我们想到了二叉树，时间复杂度是O（log2N）。搜索效率和树的深度有关，如果想要提高查询效率，那么降低树的深度是一种有效的手段。这里就采用了多叉树的方法，建立一个平衡的多叉树，在上面实现搜索。


*  B树

B树的数据结构大概如下：

![](https://segmentfault.com/img/remote/1460000020416594)

下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：

  1.根结点至少有两个子女。

  2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

  3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

  4.所有的叶子结点都位于同一层。

  5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。
  
  



* B+树

MySQL就普遍使用B+Tree实现其索引结构。与B-Tree相比，B+Tree有以下不同点：


 * B+树的所有数据都存储在叶子结点上

   1.B+树有两种类型的节点--内部结点（也称索引结点）和叶子结点。非叶子节点是内部结点，不存储数据，只存储索引，数据都存储在叶子节点。
   
   2.内部结点的key从小到大排列，key的左子树的值都小于key，右子树的值都大于等于key。
   
   3.叶子结点的key也是从小到大排列，每个叶子结点都有一个next指向相邻叶子结点
   
   4.父节点存储右结点第一个孩子的索引
  
  ![](https://segmentfault.com/img/remote/1460000020416595)
  
  
 ============================================================================================================ 
  
  

- ### # 数据库的事务


事务就是保证一组数据库操作，要么全部成功，要么全部失败，避免考虑其他网络异常和服务器宕机造成的潜在问题。



- ### # ACID原则


* Atomicity 原子性

  原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
  
  
* Consistency 一致性

  一致性是指事务使得系统从一个一致的状态转换到另一个一致状态
  
  一致性包含：
  
    * 强一致性：读操作可以立即读到提交的更新操作。

    
    * 弱一致性：提交的更新操作，不一定立即会被读操作读到，
    
    此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。
    
    
    * 最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的值。

  
* Isolation 隔离性

   多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
   
   
   隔离性不好会出现以下问题：
   
   
   * 脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。
   
   
   * 不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。
   
     **不可重复读出现的原因**：就是事务并发修改记录，
     
     **不可重复读的解决方案**
        
        * 要避免这种情况，最简单的方法就是对要修改的记录加锁，这会导致锁竞争加剧，影响性能。
        
        * 另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。
   
   
   * 幻读：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中**插入一行新数据**。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。
   
   
   **幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。**
   
   
   
     **幻读的原因**：并发事务增加记录导致的
     
     **幻读的解决方案**：这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将**事务串行化**，才能避免幻读。


   - #### #事务的隔离级别：
   
   
     * Read Uncommitted 读未提交：，最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
     
     
     * Read Committed 读已提交：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
     
     
     * Repeated Read 可重复读：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。 
     
     
     * Serialization串行化：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。写会加写锁，读会加读锁
     


   
* Durability 持久性

  持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中。


===================================================================================================================


- ### #锁


* 全局锁：对整个数据加锁。'Flush tables with read lock (FTWRL)'。当你需要让整个库处于只读状态的时候,在执行全局备份时候使用。

   如果是支持事务的引擎InooDB等：可以在可重复读隔离级别下，一次性读，备份之前开启一个事务


* 表级锁：一般在引擎中不支持事务（行锁）的时候使用，表锁的语法是 'lock tables ...read/write' 

  与FTWRL类似,可以用unlock tables主动释放锁,也可以在客户端断开的时候自动释放。需要注意,lock tables语法除了会限制别的线程的读写外,也限定了本线程接下来的操作对象。
  
  
  另一类表级的锁是MDL(metadata lock)。MDL不需要显式使用,在访问一个表的时候会被自动加上。MDL的作用是,保证读写的正确性,包含写锁、读锁。
  
  事务中的MDL锁,在语句执行开始时申请,但是语句结束后并不会马上释放,而会等到整个事务提交后再释放。


* 行锁：行锁就是一锁锁一行或者多行记录。


  在InnoDB事务中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释放,而是要等到事务结束时才释放。这个就是两阶段锁协议。
  
  
  **如果你的事务中需要锁多个行,要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**


锁的整体架构如下：

![](https://camo.githubusercontent.com/cb7782f7d8d2c9b208c20dba56abb9ddd71ececa/68747470733a2f2f706963332e7a68696d672e636f6d2f38302f76322d35636638623936666463613134323865366633636365383633666466613733655f373230772e6a7067)

* 乐观锁:通常通过使用版本号/时间戳实现

  'update table set fields = #{fields},version=#{new_version} where id=#{id} and version = #{old_version}'

  乐观锁与悲观锁不同的是，它是一种逻辑上的锁，而不需要数据库提供锁机制来支持
  
  
* 范围锁


  * 行锁：
  
     
     -记录锁：锁的是表中的某一条记录，记录锁的出现条件必须是**精准命中索引并且索引是唯一索引**，如主键id
     
     
     -GAP锁(间隙锁)：锁定的间隙为（A，B]，防止幻读发生

       * 防止间隙内有新数据被插入

       * 防止已存在的数据更新成间隙内的数
       
       
     -next-key锁（临键锁）：是记录锁加上间隙锁的组合，**锁定一个范围，并且锁定记录本身**。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

       间隙锁的触发条件是命中索引，范围查询没有匹配到相关记录。
       
       而临键锁恰好相反，临键锁的触发条件也是查询条件命中索引，不过，临键锁有匹配到数据库记录；

       但是，当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。注意：通过主键或者唯一索引来锁定不存在的值，也会产生GAP锁定。

       gap锁与行锁的组合，InnoDB中，更新非唯一索引对应的记录时会加上Next-Key锁，如果更新记录为空则只能加gap锁
  
  
  
  * 意向锁
     
     
     -意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）
     
       -共享锁：就是多个事务只能读数据不能改数据

        事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
        
        ```SELECT column FROM table ... LOCK IN SHARE MODE;```
        

    -意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）
    
      -排他锁：排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能加其他的锁了

        事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
         
        ```SELECT column FROM table ... FOR UPDATE;```
     
     **意向锁有什么好处呢？**
     
     ```
     1.事务A锁住了x行

     2.事务B申请整个表的写锁。

     3.B的申请被阻塞，直到A释放了行锁。
     
      （a）判断冲突：
               ｜step1：判断表是否已被其他事务用表锁锁表
               ｜step2：判断表中的每一行是否已被行锁锁住。

      （b）效率低下，需要全表遍历
      
      
      意向锁进行了优化
      
      1'.事务A申请意向锁，申请行锁
      
      2‘.事务B申请表写锁
      
      3‘ 判断是否阻塞：
      
        ｜step1：判断表是否已被其他事务用表锁锁表
        ｜step2：判断表中的意向锁

       

      注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。
     ```


================================================================================================================================


- ### #视图


   在MySQL里,有两个“视图”的概念:
   

   * 一个是view。它是一个用查询语句定义的虚拟表,在调用的时候执行查询语句并生成结果。创建视图的语法是create view...,而它的查询方法与表一样。


   * 另一个是InnoDB在实现MVCC时用到的一致性读视图,即consistent read view,用于支持


   -视图的作用:简化sql查询,提高开发效率

      如采购单：有价格、数量、税率、含税金额，多半没有不含税金额、税额，而这些字段在很多报表中有都会用到，所以我们可以创建一个含有计算列字段的视图来解决这个问题。


   -数据库改变视图中的数据是否改变

       若视图数据来自一个表时,修改视图中的数据,表数据会更新
       
       若视图数据来源多个表时,修改视图数据会报错,无法修改
       
       
       
- ### #大表添加字段
    ```
    1.创建一个临时表,首先复制旧表结构
    
    2.给新表加上新增的字段,此时新表是空表,加字段很快
    
    3.把旧表数据复制过来
    
    4.删除旧表,重命名新表名字
    
    注意:会损失极少量的数据,如果表的数据特别大,同时又要保证数据完整性,最好停机操作

    ```


================================================================================================================================================



- ### #引擎 InnoDB 和 MyISAM 的区别
 
 
 * 事务 
 
 
   -MyISAM不支持事务，InnoDB支持事务、外键与行锁
   
   -MyISAM的读性能强，执行速度快

   -MyISAM保存行数，InnoDB不保存具体的行数
   

 * 索引
 
 
   -MyISAM
       
      MyISAM索引和数据分开且索引有压缩，内存使用率提高不少

      通过索引直接找到叶子节点中指向具体表中的数据的那个指针
   
   
   -InnoDB
   
      InnoDB索引与数据存在一块
      
      有聚簇索引,索引数据时需要在二级索引中找到主键,后根据主键到聚簇索引中找到最终数据,需要走两次索引
      
      InnoDB不支持全文索引(5.6版本以后支持)
      
      
 =======================================================================================================================
 
 
 - ### #分库分表
---------------

* WHAT ？
  
  * 分库： 用户id直接mod分成库的数目大小，将大库分成小库

  * 分表：用户 id 直接 mod 分成表的数目大小， 将大表拆成小表
  
  
* HOW 分库分表？
  
 ```
  中间变量=user_id %(分库数量*每个库的表数量)
  库 = 取整数（中间变量/每个库的表数量）
  表 = 中间变量 % 每个库的表数量
 ```
 
 
一般就是垂直切分和水平切分，从原因入手：这时我们要看是因为表多而导致数据多，还是因为单张表里面的数据多。 


   * 如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。

   * 如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表。
   
   
   分库分表的顺序应该是先垂直分，后水平分。 因为垂直分更简单，更符合我们处理现实世界问题的方式。
   
   
   * 垂直分表

        也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。


   * 垂直分库

     垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上
     
   
   * 水平分库分表切分规则

      -RANGE：从0到10000一个表，10001到20000一个表；
      

      -HASH取模：一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。


      -地理区域：比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。


      -时间：按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。



* 分库分表造成的问题


  -单机的ACID被打破，数据到多机后，原来单机通过事务来进行处理逻辑会受很大影响
  
  -Join操作困难，因数据可能在两个数据库中了，不能方便利用数据库自身join

  -靠外键进行约束的场景会受到影响



 
* 如何解决分库分表带来的坏处

        
    -ACID解决方法
          
     两阶段提交：事务在第一阶段对资源进行准备，若在准备阶段有一个资源失败，那么在第二阶段的处理就是回滚所有资源，否则进行Commit操作
    
    -水平切分自增ID破坏

     将所有ID集中放在一个地方管理，对每个ID序列独立管理，每台机器使用ID时都从这个ID造成器上进行获取
     
    -跨库Join

     在应用层将原来数据库中Join操作分成多次数据库操作

     数据冗余：将常用信息进行冗余，将原来需要Join的返回信息变为单表查询

