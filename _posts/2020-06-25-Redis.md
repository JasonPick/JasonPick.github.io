---
layout: post
title: Redis知识
subtitle: Part I：基础知识整理
cover-img: /assets/img/path.jpg
tags: [database]
categories: ['DataBase']
---

#Redis知识整理

![](https://camo.githubusercontent.com/3031099b909e058d06f41e4257c95972888c9c18/68747470733a2f2f7777772e6c677374617469632e636f6d2f692f696d616765322f4d30312f38412f43412f43676f42356c31347258534148464d634141464b6564497a3061303837372e706e67)

先简单说一下 **Redis 的特点**

 - Redis 采用单线程模式处理请求。这样做的原因有 2 个：
     
     - 一个是因为采用了非阻塞的异步事件处理机制；
     
     - 另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。

 - Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。
 
 - Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。

 - Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。


## 第一章 Redis中的数据结构


Redis中的数据结构包含SDS、链表、字典、跳表、整数集合、压缩列表和对象


### 1. SDS( Simple dynamic String)

redis键值对中的**key都是string类型的**，redis底层是用C写的，对于String并没有直接使用C的字符数组，而是自己封装了一个sds类型.

```c
    struct sdshdr{
        //记录已使用的长度
        int len;
        //记录未使用的长度
        int free;
        //字节数组
        char buf[];

    };

```
![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528075607627-218845583.png)

**Why SDS?**


  - C的字符串api是不安全，因为在使用字符数组后，需要跟踪内存的分配，在使用之前，需要预分配内存空间，否则会有缓冲区溢出，用完一个字符串，需要回收，否则会有内存泄漏
    
    
  - SDS可以将分配内存的事封装，不让调用方得知
    
    
  - SDS采用空间预分配，惰性回收
    
   - 每创建一个新的String，不按实际大小分配，而是预分配更多内存。当字符串截断时，也不是立刻回收内存，而是减少len值，增加free值。字符串插入时，先看free够不够，
      不够再分配。这样减少了内存分配回收次数
      
      ![](https://camo.githubusercontent.com/a15b46e08382dc66e8c46aa9d5a5ac8f9cc20b60/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313730383136313431373230393039)



### 2. 链表( Linked List)

```
 typedef struct ListNode{
     //前置结点
     struct ListNode* pre;
     //后置结点
     struct ListNode* next；
     //结点的值
     void* value;
 
 };

```
可以组成一个双端链表

```
typedef struct list{
       //表头结点
       ListNode* head;
       //表尾结点
       ListNode* tail;
       //表包含的结点数量
       unsigned long len；
       //节点复制函数
       void (*dup) (void *ptr);
       //节点值释放函数
       void (*free) (void *ptr);
       //节点值对比函数
       int (*match) (void *ptr,void *key);
};
```

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528074403440-111834793.png)



Reis链表的特性：

 - 双端 ：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。
 
 - 无环 ：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。
 
 - 多态 ：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。
 
 - 带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。
 

### 3. 字典 
 
 
 字典用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。Redis 的字典使用哈希表作为底层实现。
 
 ```
 typedef struct dictht{
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
 
}dictht
 
 ```
 
 ```
 typedef struct dictEntry{
     //键
     void *key;
     //值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
 
     //指向下一个哈希表节点，形成链表
     struct dictEntry *next;
}dictEntry
 ```
 
 ![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528080655703-1600710948.png)
 
 
注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。


* 哈希函数定义如下：

```
#1、使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);
#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值
index = hash & dict->ht[x].sizemask;

```

* 扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：
       
       ```
　　　　  1.如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used\*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）
        
          相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。

　　　　　 2.重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。

　　　　   3.所有键值对都迁徙完毕后，释放原哈希表的内存空间。
      ```


　- 触发扩容的条件：

　　　　　　* 服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。

　　　　　　* 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。

　　　　ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。
    
    

　- 渐近式 rehash

　　**什么叫渐进式 rehash？**
    
   也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。
       
   如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作
   
   所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。
   但是进行 增加操作，一定是在新的哈希表上进行的。
   
   
   
   ### 4.跳跃表(skiplist）
   
   跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。
   
   跳跃表具有平均O(logN)最坏O(N)的复杂度的节点查找，还可以通过顺序性操作来批量处理节点，效率与平衡树相媲美。
   
   ```
               typedef struct zskiplistNode {
                 //层
                 struct zskiplistLevel{
                       //前进指针
                       struct zskiplistNode *forward;
                       //跨度,用来计算rank的
                       unsigned int span;
                 }level[];

                 //后退指针
                 struct zskiplistNode *backward;
                 //分值
                 double score;
                 //成员对象
                 robj *obj;

            } zskiplistNode
   
   ```
   
   整个链表结构如下
   
   ```
           typedef struct zskiplist{
             //表头节点和表尾节点
             structz skiplistNode *header, *tail;
             //表中节点的数量
             unsigned long length;
             //表中层数最大的节点的层数
             int level;

        }zskiplist;
   ```
   
   
   具有如下性质：

　　1. 由很多层结构组成；

　　2. 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；

　　3. 最底层的链表包含了所有的元素；

　　4. 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；

　　5. 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；
  
  ![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528210921601-949409375.png)
  
  
  跳表操作：
  
   - 搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。

　　- 插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。

　　- 删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。
  
  
### 5.整数集合(intset)


整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。


```
typedef struct intset{
     //编码方式
     uint32_t encoding;
     //集合包含的元素数量
     uint32_t length;
     //保存元素的数组
     int8_t contents[];
 
}intset;
```

* 升级

　　当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：
   
   ```
　　1、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。

　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。

　　3、将新元素添加到整数集合中（保证有序）。

　　升级能极大地节省内存。
   ```
   
* 降级

　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。


### 6.压缩列表(ziplist)


压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的**顺序型数据结构**.

一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。


**压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存**


![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528215852732-1088896020.png)


压缩列表每个节点的构成：

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528223605060-899108663.png)

 - previous_entry_ength：记录压缩列表前一个字节的长度。
 
   - previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，
   
   - 如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以**从尾部向头部遍历**。这么做很有效地减少了内存的浪费。

- encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。

- content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。



### 6.对象


在Redis中，并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。


#### 6.1 对象的数据结构


对象的结构如下：

```
    typedef struct redisObject{
         //类型
         unsigned type:4;
         //编码
         unsigned encoding:4;
         //指向底层数据结构的指针
         void *ptr;
         //引用计数
         int refcount;
         //记录最后一次被程序访问的时间
         unsigned lru:22;

    }robj
```

* 其中type属性记录了数据的类型，type的值与实际数据类型的对应关系

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180529081528965-1759247786.png)


* encoding属性：

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180529083236432-1997988837.png)


其中每个数据结构，都可以用至少两种底层的数据结构来实现

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180529083343934-438384530.png)


下面我们来深入看看每个类型是怎么通过其底层的数据结构实现的把！


#### 6.2 字符串对象


　字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。注意字符串的长度不能超过512M。
 

　字符串对象的编码可以是int，raw或者embstr。int 编码是用来保存整数值，raw编码是用来保存长字符串，而embstr是用来保存短字符串。
 

　　- int 编码：保存的是可以用 long 类型表示的整数值。

　　- raw 编码：保存长度**大于44字节的字符串**（redis3.2版本之前是39字节，之后是44字节）

　　- embstr 编码：保存长度**小于44字节的字符串**（redis3.2版本之前是39字节，之后是44字节）
  
  
  其中raw与embstr有什么区别呢？为什么要有两种编码呢？
  
  
  embstr 编码是专门用来保存短字符串的一种优化编码
  
  raw 和 embstr 的区别如图所示
  
  ![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530075617307-666390009.png)
  
  embstr与raw都使用redisObject和sds保存数据，
  
  区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。
  
  * embstr的优点： 与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。
  
  * embstr的缺点：如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。
  
  
  **编码的转换**


　　- 当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。

　　- 对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。
  
  
  
#### 6.3 列表对象

'rpush numbers 1 "three" 5'

list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。

列表对象的编码可以是 ziplist(压缩列表) 和 linkedlist(双端链表)


当同时满足下面两个条件时，使用ziplist（压缩列表）编码：

　　- 列表保存元素个数小于512个

　　- 每个元素长度小于64字节


不能满足这两个条件的时候使用 linkedlist 编码。

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530110113859-1999704925.png)



#### 6.4 哈希对象


哈希对象的键是一个字符串类型，值是一个键值对集合。

哈希对象的编码可以是 ziplist 或者 hashtable。

```
hset profile name "Tom"
hset profile age 25
hset profile career "Programmer"
```

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530122525661-752750675.png)

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530122608271-980707096.png)


* ziplist 和hashtable的区别

其中压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构
相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。


* 编码转换

　　和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码：

　　 - 列表保存元素个数小于512个

　　 - 每个元素长度小于64字节

　　不能满足这两个条件的时候使用 hashtable 编码。
  
  
  
#### 6.5 集合对象


集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合


'SADD numbers 1 3 5'


**集合对象的编码可以是 intset 或者 hashtable。**

　　- intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中。

　　- hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。


![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530131318187-33688989.png)


![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530131811531-167113910.png)


* 编码转换

　　当集合同时满足以下两个条件时，使用 intset 编码：

　　 - 集合对象中所有元素都是整数

　　 - 集合对象所有元素数量不超过512

　　不能满足这两个条件的就使用 hashtable 编码


#### 6.6 有序集合


和上面的集合对象相比，有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据

'ZADD price 8.5 apple 5.0 banana 6.0 cherry'

有序集合的编码可以是 ziplist 或者 skiplist。

　　* ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，
  
     第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。

![](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530210919276-1209186625.png)

 
 一个 zset 结构同时包含一个字典和一个跳跃表：

```
typedef struct zset{
     //跳跃表
     zskiplist *zsl;
     //字典
     dict *dice;
} zset;
```

![](/assets/img/blog/Snip20200627_10.png)

- 字典的键保存元素的值，字典的值则保存元素的分值；

- 跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。

　　这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。


**为什么同时使用两个数据结构**


其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是：

- 假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；

- 假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。


* 编码转换

　　当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：

　　1、保存的元素数量小于128；

　　2、保存的所有元素长度都小于64字节。

　　不能满足上面两个条件的使用 skiplist 编码。


#### 6.7 应用场景


   - 对于string 数据类型，因为string 类型是二进制安全的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作计数器（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。

　　- 对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。

　　- 对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能

　　- 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

　　- 对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等。



#### 6.8 内存回收机制


Redis自己构建了一个内存回收机制，主要使用来引用计数。通过在 redisObject 结构中的 refcount 属性实现。这个属性会随着对象的使用状态而不断变化：

　　1. 创建一个新对象，属性 refcount 初始化为1

　　2. 对象被一个新程序使用，属性 refcount 加 1

　　3. 对象不再被一个程序使用，属性 refcount 减 1

　　4. 当对象的引用计数值变为 0 时，对象所占用的内存就会被释放。
  
  
 问题：引用计数如果有循环引用造成内存泄露。那么 Redis 如何解决这个问题呢？
 
  
  redis.conf 配置文件时，在  MEMORY MANAGEMENT 下有个 maxmemory-policy 配置

　　maxmemory-policy ：当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：
  
  
       1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 

　　　　2）allkeys-lru   利用LRU算法移除任何key 
 
 
 内存共享 
 
 
　　refcount 属性除了能实现内存回收以外，还能用于内存共享。


　创建一个键为 k1，值为100的字符串对象，接着创建一个键为 k2，值为100 的字符串对象，那么 Redis 是如何做的呢？

　　1、将数据库键的值指针指向一个现有值的对象

　　2、将被共享的值对象引用refcount 加 1
  
 
 
 #### 6.9 空转时常
 
 
 　在 redisObject 结构中 lru 属性记录了对象最后一次被命令程序访问的时间。

　　使用 OBJECT IDLETIME 命令可以打印给定键的空转时长，通过将当前时间减去值对象的 lru 时间计算得到。
