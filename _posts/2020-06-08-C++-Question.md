---
layout: post
title: C++ Basic 笔记
subtitle: Part II 面经整理
tags: [basic,c++]
comments: true
categories: ['C++']
---

1. **C与C++的区别**


  * C++是面向对象的语言，C是面向过程的语言
  
  * C++具有三大特性：封装、继承和多态
  
  * C++相比C，增加了许多安全的功能，比如强制类型转换
  
  * C++支持范式编程，比如模版类、函数模版
  
  
  2. **static 关键字**
  
  
   * 全局静态变量：在全局变量之前加static。
   
     * 内存中位置：静态存储区
     
     * 初始化：自动初始化为0
     
     * 作用域： 全局静态变量在声明文件之外是不可见的
    
    
   * 局部静态变量：
   
     * 内存中位置：静态存储区
     
     * 初始化：自动初始化为0
     
     * 作用域： 局部作用域，当离开定义的函数时候，作用域结束。但是当局部静态变量离开作用域后，没有被销毁而是停留在内存中，直到再次被调用。
    
    
   * 静态函数：
     
     * 静态函数只在声明他的文件中可见，不能用于其他文件
     
     * 优点：声明static后仅仅可以在本cpp内使用，不可以被其他文件使用，**避免了命名冲突**
     
     * 使用：如果要在多个cpp内使用这个函数，在头文件中声明这个函数（不可以加static）。否则在cpp内部需要加上static声明。
     
    
   * 类的静态成员：
   
     * 类的静态成员，存储在一处，供所有对象共享。
     
     * 作用：类的静态成员可以实现，同一类多个对象之间的数据共享，也保证了安全性。
     
  
  2. **C++中四种cast**
  
  
   * static_cast
   
     * 用于各种隐式转换，默认的类型准换，如非const转化为const，void* 转化成指针，static_cast还可以用于多态向上转化(用于向下转化不安全)
     
     
   * dynamic_cast
   
     * 可以将基类的指针转化成为派生类的**指针或者引用**，在没办法使用虚函数的时候，只能使用派生类动态转化。
     
       * 向上转化安全 
     
     * 场景：类的静态函数中不能出现非静态的成员，要想引用的话只可以通过对象来引用。
     
   
   * reinterpret_cast
   
     * 提供不相关类型之间的转换，如int* 与 char*
     
   
   * const_cast
   
     * 将const类型转化成为非const类型，用于场景例如const类型的数想要传入作为const类型的参数：
     
     
  
  3. **C++中的指针和引用的区别**
  
  
   * 指针p：指针是一个对象，有地址&p和存储的值p，指针存储的数据类型是数据的地址，要访问存储地址对应对象的值，要用*p
   
     * 指针常量：指针对象存储的地址是不可以改变的
     
     * 常量指针：不能通过该指针来改变这个指针指向的对象
     
     
   * 引用：程序在定义引用时，把引用和初始值绑在一起。程序必须在定义时候就对引用初始化，并且一旦定义就不可以和其他的对象绑定在一起。 引用可以看作通过常量指针来实现的。
   
   
   * 主要的区别
     
     * 指针占空间，引用不占额外的空间
     
     * 指针可以被初始化为null，引用必须初始化
     
     * sizeof(\*) = 4, size_of(&)是非法的
     
     
  3. **C++中的智能指针**
  
  
  c++智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。在ps对象过期的时候，析构函数将删除指针指向的内存。
  
  所有的指针都有一个explicit构造函数，因此不能自动将指针转化为智能指针，必须显示的调用 _pd = shared_ptr<double>(p_reg)_ 
  
  
   * auto_ptr：**为了避免潜在的内存崩溃问题**，在c++11中弃用了auto_ptr。举个例子
   
      ```c++
      auto_ptr< string> ps (new string ("I reigned lonely as a cloud.”）;
      auto_ptr<string> vocation; 
      vocaticn = ps;

      ```
      
     两个指针同时指向一个string对象，会被delete两次，这是不允许的，有几种方法可以避免这种情况
   
     * 建立所有权概念：对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。
     
     * 创建智能更高的指针，使用引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。
     
     使用auto_ptr造成内存崩溃的例子
     ```
     auto_ptr<string> film (new string("Duck Walks")),
     auto_ptr<string> pwin;
     
     pwin = films; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针

     cout << "The nominees for best avian baseballl film are\n";
     
     cout << film << endl;
     cout << "The winner is " << *pwin << endl;
     cin.get();

     return 0;
     
     ```
     如果是unique_ptr,编译器会指出潜在错误
     
     如果是shared_ptr,使用引用计数，不会出现多删除一次的错误
     
   
   * unique_ptr：相比于auto_ptr来说，更加安全
   
     * 但unique_ptr还有更聪明的地方。有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。
     
     ```
     unique_ptr<string> pu1(new string ("hello world"));
     unique_ptr<string> pu2;
     pu2 = pu1;                                      // #1 not allowed
     unique_ptr<string> pu3;
     pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
     
     ```
   
   
   * shared_ptr：实现了一个共享的概念，多个指针可以指向同一个对象，通过引用计数来保证对象只会被释放一次。shared_ptr解决了auto_ptr所有权上的独占性，实现了共享。
   
   
   * weak_ptr：不控制对象生命周期的智能指针，用于解决shared_ptr相互引用的时候的死锁问题（两个shared_ptr相互引用，那么count永远不为0，不会释放）。它可以用weak_ptr和share_ptr进行初始化，但不会引起计数器的增加和减少。
   
     * weak_ptr的使用：它没有重载operator->和operator \*操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。
   
   
  4. **为什么虚构函数必须是虚函数，为什么默认析构函数不是虚函数**
  
  
  * 将父类的析构函数设置为虚函数，当创建一个子类实例的时候，使用基类的指针指向子类的对象，释放的时候可以释放掉子类的空间，防止内存泄漏
  
  * 因为虚函数要有虚函数表和虚表指针，会占用额外的内存空间。只有当类会被继承的时候才使用虚函数，否则造成内存资源的浪费。因此默认析构函数不是虚函数。
  

  5. **函数指针了解一下**
  
  
  函数指针是指向函数的指针。和其他类型的指针一样，函数指针也是指向一个地址，在C编译的时候每个函数都有一个入口地址，函数指针指向该地址。
  
  可以用该指针变量调用函数。
  
  用途在于：
  
  * 调用函数做参数，例如回调函数
  
   ```c++
   char * fun (char *p){...}//函数
   char* (* pf)(char *p);//函数指针
   
   pf = fun;//使用函数指针指向fun函数
   
   pf(p);//通过函数指针pf回调fun
   
   ```
   
   
  6. **C++中析构函数的作用**
  
  
  析构函数与构造函数对应，当对象结束生命周期时候，析构函数会自动执行。
  
  析构函数的特点，没有参数，没有返回值，当用户没有定义时，会有一个默认的析构函数。
  
  析构函数的注意事项：
  
   * 当类中存在指针的时候，那么在显示指向析构函数之前，释放掉申请的内存空间，防止内存泄漏
   
   * 析构函数执行顺序： 派生类的析构函数 -> 对象成员的析构函数 -> 基类的析构函数
   
   
   
  7. **静态函数和虚函数的区别**
  
  
  * 静态函数在编译的时候才确定运行机制，虚函数在运行的时候进行动态绑定。
  
  * 虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销
  
  
  
  8. **重载和覆盖**
  
  
  * 重载：两个函数名相同，但是参数列表不同，返回值类型无要求
  
  * 覆盖： 子类继承父类，父类中的函数是虚函数，子类中重新定义这个函数的细节。
  
  
  9. **strcpy 和 strlen**
  
  
  strcpy是字符串拷贝函数， char* strcpy(char* dest, const char* src);
  
  从src逐个字节拷贝到des，直到遇到0结束，没有制定长度，可能会导致拷贝越界，造成缓冲区溢出。安全版本是 char* strncpy(char* dest, const char
 * src, int n)

  strlen函数是计算字符串长度的函数，从开始到0字符结束
  
  
  10. **多态和虚函数**
  
  
  多态的实现主要分为静态多态和动态多态，
  
   * 静态多态：函数重载，在编译时候就已经确定
   
   * 动态多态：虚函数机制，在运行时候绑定
   
   虚函数实现机制：在包含虚函数的类中，有个虚表指针指向虚函数表，虚函数表中存放父类的虚函数的地址，当子类继承的时候，继承虚表，并重写虚函数，虚表中的地址变为新的函数地址
   
   
  11. **const char * 和 char * 和 const char[] 和 char[]**
  
  
  * const char* arr = "123";//不能通过arr来修改“123”。字符串123保存在常量区
     
     * char * const ptr;//这里指的是ptr是一个const，不能修改ptr指针
  
  char * brr = "123";//123保存在常量区，与arr指向同一个位置
  
  const char crr[] = "123";//这里的123放在栈上
  
  char drr[] = "123";//这里的123放在栈上
  
  
  c++的常量是一个top-level const,常量必须初始化。局部变量常量放在栈区，全局变量，常量放在静态存储区。字面zhi常量，常量存放在常量存储区。
  
  
  12. **c++一些基础问题**
  
  
  * 两个函数一个带const，一个不带，具有相同的函数名会有问题吗？ 不会，相当于函数重载，返回类型不同
  
  
  * 隐式转换发生在什么时候： 
    
     * 内置类型，低精度变量给高精度变量赋值的时候
     
     * 对象只存在一个参数的构造函数，系统调用时直接传入该参数，编译器会自动调用构造函数生成临时对象
     
  
  * c++栈空间的最大值 1M 可调节
  
  
  * new/delete 和 malloc/free的区别：
  
    * new/delete是c++关键字，malloc/free是c库函数，必须声明空间大小
    
    * 对于类，malloc/free不会调用构造函数和析构函数
    
    * malloc返回的指针需要强制转换，new不用
   
   
  * C语言函数调用： 每个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压入栈中，然后把当前函数的esp指针压入栈中。
  
  
  * 参数的压栈顺序：从右到左
  
  
  * c++返回值：生成一个临时变量，把引用作为一个函数参数，传回去
  
  
  * C++拷贝赋值函数的形参能否使用值传递：NO，调用拷贝构造函数的时候，实参传递给形参，这个过程又要调用拷贝构造函数，一直循环。
  
  
  
     
  
   
  


 


       
    
    
