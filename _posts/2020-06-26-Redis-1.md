---
layout: post
title: Redis知识
subtitle: Part II：进阶知识整理
cover-img: /assets/img/path.jpg
tags: [database]
categories: ['DataBase']
---

#Redis知识整理


![](https://camo.githubusercontent.com/3031099b909e058d06f41e4257c95972888c9c18/68747470733a2f2f7777772e6c677374617469632e636f6d2f692f696d616765322f4d30312f38412f43412f43676f42356c31347258534148464d634141464b6564497a3061303837372e706e67)


## What is Redis？

{:.box-warning}

Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。


* 数据结构：Redis支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）


* 范围查询：Redis支持Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。


* 功能： Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。


* 持久化：Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。




### 为何Redis单线程这么快


Redis 单线程但性能依旧很快的主要原因有以下几点：

- 基于内存操作：Redis 的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高；

- 数据结构简单：Redis 的数据结构比较简单，是为 Redis 专门设计的，而这些简单的数据结构的查找和操作的时间复杂度都是 O(1)，因此性能比较高；

- 多路复用和非阻塞 I/O：Redis 使用 I/O 多路复用功能来监听多个 socket 连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，
同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的性能；

- 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生。

  
  
  
### Redis单进程单线程模型


首先我们了解一下为什么Redis是单线程的

**Why 单线程**

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了


**Redis内部实现原理**

- 首先需要注意Redis的单线程是针对网络请求处理时候的单线程，并不是一个Redis Server就只有一个线程。Redis内部有一个内部使用文件事件处理器 file event handler，
这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。

- 它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。

- 多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，

事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

  Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。





### 多路复用I/O模型


* 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

* 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力。

  - 在空闲的时候，会把当前线程阻塞掉；

  - 当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（
epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作
  
  
优点：

 - 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）
 
 - 系统开销小，系统创建进程和线程，也不用维护其他线程
 
```
絮叨时间到了，一直在各种各样的技术文章中看到多路复用的epoll，到底什么是epoll，原理是什么，我一直没有弄懂，今天来总结一下

首先要清楚几点前提：

1.网卡收到数据后会存储到内存中，让操作系统读取。

2.当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。

3.阻塞是不占用cpu资源的，为什么

答：当进程A创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象，包含了发送缓冲区、接收缓冲区、等待队列等成员。
等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。

```
