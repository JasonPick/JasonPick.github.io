---
layout: post
title: Redis知识
subtitle: Part II：进阶知识整理
cover-img: /assets/img/path.jpg
tags: [database]
categories: ['DataBase']
---

#Redis知识整理


![](https://camo.githubusercontent.com/3031099b909e058d06f41e4257c95972888c9c18/68747470733a2f2f7777772e6c677374617469632e636f6d2f692f696d616765322f4d30312f38412f43412f43676f42356c31347258534148464d634141464b6564497a3061303837372e706e67)


## What is Redis？

{:.box-warning}

Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。


* 数据结构：Redis支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）


* 范围查询：Redis支持Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。


* 功能： Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。


* 持久化：Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。




### 为何Redis单线程这么快


Redis 单线程但性能依旧很快的主要原因有以下几点：

- 基于内存操作：Redis 的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高；

- 数据结构简单：Redis 的数据结构比较简单，是为 Redis 专门设计的，而这些简单的数据结构的查找和操作的时间复杂度都是 O(1)，因此性能比较高；

- 多路复用和非阻塞 I/O：Redis 使用 I/O 多路复用功能来监听多个 socket 连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，
同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的性能；

- 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生。

  
  
  
### Redis单进程单线程模型


首先我们了解一下为什么Redis是单线程的

**Why 单线程**

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了


**Redis内部实现原理**

- 首先需要注意Redis的单线程是针对网络请求处理时候的单线程，并不是一个Redis Server就只有一个线程。Redis内部有一个内部使用文件事件处理器 file event handler，
这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。

- 它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。

- 多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，

事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

  Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。





### 多路复用I/O模型


* 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

* 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力。

  - 在空闲的时候，会把当前线程阻塞掉；

  - 当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（
epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作
  
  
优点：

 - 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）
 
 - 系统开销小，系统创建进程和线程，也不用维护其他线程
 
 
 ![socket的等待队列](https://pic1.zhimg.com/80/v2-1c7a96c8da16f123388e46f88772e6d8_1440w.jpg)
 
```
絮叨时间到了，一直在各种各样的技术文章中看到多路复用的epoll，到底什么是epoll，原理是什么，我一直没有弄懂，今天来总结一下

首先要清楚几点前提：

1.网卡收到数据后会存储到内存中，让操作系统读取。

2.当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。

3.阻塞是不占用cpu资源的，为什么

答：当进程A创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象，包含了发送缓冲区、接收缓冲区、等待队列等成员。
等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。进程A进入阻塞后，就加入等待队列，工作队列中只有B和C进程了。
进程A被阻塞但是不会占用cpu资源。

4.内核接收网络数据的旅程：网卡传送数据到内存 -> 网卡发出中断信号：有数据到啦！ -> cpu执行中断程序：将网络数据写入socket缓冲区，并唤醒进程A

    A.操作系统怎么知道网络数据对应哪个socket？
    
     每个socket都有端口号，而每个网络数据都有对应的ip地址和端口号。
    
    B.如何同时监听多个socket
    
      1）select思想：select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket
      
                    那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。
                    
                    当任何一个socket收到数据后，中断程序将唤起进程
                    
                    所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面
                    
                    优点：简单
                    
                    缺点：不知道是那个socket要遍历一次，把进程A加入所以socket遍历一次，将进程A从所有socket中删除要遍历一次
                  
                  
  现在我们可以来解释epoll的原理了
  
  epoll针对select进行了修改
  
  1. 将维护队列与阻塞进程分离
  
     select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一，
     
     epoll先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。
     
                int s = socket(AF_INET, SOCK_STREAM, 0);   
                bind(s, ...)
                listen(s, ...)

                int epfd = epoll_create(...);
                epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

                while(1){
                    int n = epoll_wait(...)
                    for(接收到数据的socket){
                        //处理
                    }
                }
  
  2. 就绪列表
  
     select低效的原因还因为不知道哪一个socket收到了数据，
     
     epoll方法内核维护了一个就绪列表，引用收到数据的socket避免遍历。
     
     
 epoll原理和流程
 
 1.创建对象：在文件系统中创建一个event_poll对象
 
 2.维护监视列表：将event_poll加入socket1、socket2、socket3的等待队列
 
 3.接收数据：收到数据后中断程序直接操作event_poll而不是进程。
 
           中断程序给event_poll的rdlist引用收到数据的socket。
  
 
 4.阻塞和唤醒进程：当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。
  

```


### Redis特性


- 速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型：支持string，list，set，sorted set，hash

- 支持事务：操作都是原子性,因为其是单线程的

- 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除



### Redis分布式锁


总体思路：先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

```
public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) {
        Long result = jedis.setnx(lockKey, requestId);
        if (result == 1) {
            // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁
            jedis.expire(lockKey, expireTime);
        }
    }

```

但是这样的思路有一个问题，如果锁没释放的时候进程就崩溃了，那么这个锁就永远不会释放了。

那么怎么解决呢？思路就是将两个操作合并成为一个保证原子性。

'SET key value [EX seconds] [PX milliseconds] [NX|XX]'




### 如何从海量key里面查找某一固定前缀的key


使用keys指令可以扫出指定模式的key列表。

'keys k1*'会一次性返回所有符合描述的key


**容易造成的问题**

造成卡顿。Redis的单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。


**解决方案**

这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长

'scan 0 match k1* count 10' 但是不保证每次执行都返回某个给定数量的元素,支持模糊查询




### Redis的消息异步队列


整体思路：一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。


**那么sleep的替代方案是什么呢**：

list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。

'blpop testlist 30'

**生产一次消费多次是怎么实现的呢** 

pub/sub模式主题订阅者模式实现1 vs N

发送者发送消息，订阅者接收消息，订阅者可以订阅任意数量的频道

在消费者下线的情况下，生产的消息会丢失，因为消息的发布是无状态的。


**延时队列的实现**

使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，

消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。





### Redis的持久化实现


RDB做镜像全量持久化，AOF做增量持久化。

因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。

在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。


{:.box-note}

Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；  
AOF关闭或者AOF文件不存在时，加载RDB文件；  
加载AOF/RDB文件城后，Redis启动成功；  
AOF/RDB文件存在错误时，Redis启动失败并打印错误信息  



* RDB

  - 保存某个时间点的全量数据快照
  
  - RDB文件的创建通常有SAVE命令和BGSAVE命令
     
     - SAVE 命令会阻塞进程
     
     - BGSAVE会fork一个子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。
  
  缺点：
       
   - RDB可能会丢失最新阶段的数据


* AOF(Append-Only-File)持久化:保存写状态

   - 记录下除了查询以外的所有变更数据库状态的指令,以append加入AOF文件中
   
   - AOF记录所有写操作，随着时间增加会很大，使用重写来解决，
   
       - 创建一个子进程，将父进程的AOF写入子进程中
       
       - 如果期间有新的数据写入，写入原来的AOF中，为了同步还要追加到AOF重写缓冲区一份。



### Redis的Pipeline


为了提高redis的读写能力，所以就有了pipeline的出现，对于多个命令执行，不再同步等待每个命令的返回结果。我们会在统一一个时间点来获取response。

优点：可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。




### Redis的同步机制


Redis可以使用主从同步。可以让master机器去写，数据同步给别的slave机器，分发掉大量的请求，解决高并发问题。

- 第一次同步时，slave发送psync，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，

- 待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。

- 加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

- 后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。



### Redis的内存淘汰机制


Redis的过期策略，是有定期删除+惰性删除两种。


* 定期删除：设置一个过期时间，过一段时间检查一下

* 惰性删除：等查询了看看过期没，过期就删了不返回

为什么不全部过期删：所有key遍历一遍对性能影响很大


漏网之鱼：**内存淘汰策略**

当内存使用达到maxmemory极限时,需要使用LRU淘汰算法来决定清理掉哪些数据,以保证新数据的存入

 - volatile-lru：从设置过期时间的数据集中挑选出最近最少使用
 
 - volatile-ttl：从设置过期时间数据中选将要过期数据

 - volatile-random：从已设置过期时间数据中选任意数据

 - allkeys-lru 从所有数据集中选最近最少使用

 - allkeys-random 从所有数据集中任意选数据

 - noeviction 禁止驱逐数据





### Redis的集群

Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。




        

